# 线程间的通信方式
主要是总结线程间的通信方式有哪些.

## 通信方式
1. 通过`synchronized`进行通信
```java
public class MyObject {

    synchronized public void methodA() {
        //do something....
    }

    synchronized public void methodB() {
        //do some other thing
    }
}

public class ThreadA extends Thread {

    private MyObject object;
    //省略构造方法
    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}

public class ThreadB extends Thread {

    private MyObject object;
//省略构造方法
    @Override
    public void run() {
        super.run();
        object.methodB();
    }
}

public class Run {
    public static void main(String[] args) {
        MyObject object = new MyObject();

        //线程A与线程B 持有的是同一个对象:object
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();
    }
}
```
在上例中, 因为`ThreadA`和`ThreadB`持有有共同的变量`object`, 因此通过`synchronized`的方式可以实现两个线程的串行执行. 以为最终被锁住的应该是`object`对象。 同时根据`happend-before`原则, 释放锁在获取所之前进行的, 因此线程对同一个对象的修改可以同步给另一个线程。

这种方式是通过`共享内存`的方式实现两个线程的通信。

2. 通过`while`循环的方式
```java
@Test
public void testWhile() throws InterruptedException {

  ObjectValue objectValue = new ObjectValue();

  Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
     while(true) {
       for (int i = 0, len = 10; i < len; i++) {
          objectValue.add();

         System.out.println("添加了" + (i + 1) + "个元素!");
         // 该处会有一个sleep的操作，为了让工作内存有时机能够把数据同步到主内存之中
//           try {
//             Thread.sleep(1000);
//           } catch (InterruptedException e) {
//             e.printStackTrace();
//           }
       }
     }
    }
  });

  Thread threadB = new Thread(new Runnable() {
    @Override
    public void run() {
      while (true) {
        System.out.println("ThreadB 获取线程的size: " + objectValue.size());
        // 该条件会被击穿, 因为数据延迟写入主内存之中
        if (objectValue.size() == 5) {
          System.out.println("==5条件成立, 线程B退出");
          break;
        }
      }
    }
  });

  thread.start();
  threadB.start();

  thread.join();
  threadB.join();
}

private class ObjectValue {
    private List<String> list = new ArrayList<>();

    public void add() {
      list.add("elements");
    }

    public int size() {
      return list.size();
    }
  }
```
以上程序存在以下问题:
- 线程B是一个空循环, 没有做其他的事情, 比较耗费CPU的资源
- `ObjectValue`中的`list`中的值会使得工作内存到主内存的数据同步延迟
- (可见性): 线程B中的条件`==5`的条件可能会被击穿, 因为线程B始终都是读取的本地内存的缓存, 不能保证数据同时是最新的数据, 因此可能会导致死循环
- 该处`ObjectValue`中的`list`使用`volatile`也不能解决问题, 因为`volatile`只是保证了线程每次都能够读到主内存中最新的数据, 但是主内存的数据可能在线程B处理过程中, 被修改了很多次.


## 参考
